

## CAP理论
基本需求：写要正确，读要正确
- 机制1 强一致性
保持内容一致，不允许消息丢失，各个节点同步。任何一个节点上操作了一个数据，其他节点上都对这个数据加锁，然后同步。

存在问题显然是效率低。要等到消息传到所有的节点才能用。并且会存在短板问题。单一节点太慢，整体都慢；单一节点失效，整体失效。

- 一致性
1. 强一致性
任何节点任何时间数据都是一致的。比如机制1.读简单，从任意单一节点读。
2. 最终一致性
允许出现有一段时间，各个节点上的数据是不一样的。只需要在这段时间之后最终保持一致。系统提供工具确保读写一致。读起来复杂一些，需要从多个节点中读并且进行判定。
3. one
常见于热备份的情况。

- 机制2：Quorum protocol 最终一致性
    - N 存储数据的节点数
    - W 在put请求中成功完成写操作的节点
    - R 在get请求中成功完成读操作的节点
    - W+R>N, W>N/2
超过一半的反馈到来(W>N/2)就允许了。之前有短板问题的时候，因为我们的节点是弹性变化的，可能在一直增长，这带来的问题是可能导致越增加越慢。
这样只等超过一半，相当于只需要等第K快的就可以了。

注意，没改过来的节点不意味着不用改了，而是说我这次先不等你了，我的锁已经放开了，没改过来的节点后面再慢慢改（有日志等工具，确保一定会改回来）。

- 举例：N=3
这时发生一个写操作，把所有的value从1变成2.
    - 强一致性：W=3，所有的都变成2，读的时候从任意一个节点读都可以，故R=1（意味着只需要读一个就能读到正确的节点）。
    - quorum：W=2就可以。这时候有两个节点value=2，还剩一个value=1。那么怎么读呢？由于规定了W+R>N，所以这时候至少应该令R=2，也就是说，我只要从所有节点中读至少2个，那么这2个中一定有一个正确的（更新后的，value=2）。至于怎么找正确的，可以利用标记，时间戳、版本号等。

- 对比：

总的来说，强一致性读快，最终一致性写快。要考虑业务的读写规模的对比。另外也要考虑到读操作天然比写操作要快。

架构设计很重要的一环是实现机制的设计，实现机制要求能够应对各种情况。保障数据准确性，保证效率，保证实现手段简单。

## 主从机制
- 一主多从结构
之前常见的master和data的也是主从机制，主节点管理，从节点工作。但是不是这里谈到的。

- 数据库主从分离
这里说的主节点处理核心工作。

单一库负载压力太大，需要多个库来分摊。

读库的分摊和写库的分摊。适用于读多写少的应用场景。
- 控制策略1 半同步复制

读请求和从库交互，写请求和主库交互。从库和主库之间交互。

- 控制策略2 中间件控制

写请求到来的时候在中间件上进行一个记录，先写主库，然后同步从库。主库的写完成的时候要给中间件反馈。

读请求岛来的时候先从中间件上过一下，看看有没有对应的写，如果有，如果没有。

- 控制策略3 缓存策略

写请求记录到相应的缓存中去，缓存容量有限，它只存放数据的标识类信息（如主键）。而中间件中可以自行设计，例如可以保存这一次写的内容。主库再把数据交给从库。

## Paxos 共识模式
以上都是有主控的方式。

分布式系统中不同节点的通信方式，包括消息传递，共享内存等。

全局时钟的问题

## PBFT 实用的拜占庭容错算法


## 容错
根据严重程度，有的属于故障，有的属于问题。容错专指系统能够**自行解决出现的问题，保证服务不间断。**
自行解决意味着自行能感知到问题的发生。

SLA ITIL
1. 硬件问题：有永久有间歇有瞬时
2. 软件问题：现在松耦合的架构加大了问题的复杂性

冗余的系统不一定能容错，但是容错的系统一定是冗余的。关键在于冗余的设置，以及系统自行进行补救的手段是什么。

## 存储的容错
### 分布式文件系统的读写（磁盘）
- GFS的容错机制
master的容错：命名空间、chunk与文件名的映射通过日志提供容错；

chunk server的容错

- HDFS的容错机制
namenode靠镜像+日志，有热备份，能够自动恢复

datanode通过心跳信号向主节点报告。心跳信号是主节点对辅节点进行感知的方式，是实现容错的前提。

- HDFS读文件容错
读数据的时候如果遇到错误，会从距离出错datanode最近的另一个datanode中读取数据，并记住这个故障节点，之后不要在从这里读——这时候不要通知namenode，一方面错误可能来源于读数据方，另一方面namenode会通过心跳机制来检测到它的出错。
容错的过程中也要考虑效率问题，不要同一个错误重复发生；

校验和确认来确保块中的数据完整，在每次读取数据的时候进行校验；如果读某个块发现了数据有错，那么上报给namenode，然后再从别的datanode中找冗余数据。最后一步中比较关键的是上报，因为这时候是经过校验来发现当前datanode中数据损坏了，所以一定是节点错了。注意，心跳机制只能监测到datanode本身出故障，但是它永远不会知道节点中的数据是否出错。

- HDFS写文件容错
加到最前端：当前节点中的数据尽快写回去。

## 内存数据库Redis

### 介绍
快，断电丢失。

特点：内存数据库的启动和关闭比普通数据库慢很多。内存型数据库都有对应的磁盘空间，启动的时候先从磁盘中读取回来，关闭之前再写回到磁盘中实现持久化。

问题：还没有持久化的时候断电了怎么办？

内存拷贝机制

主从复制的过程。

内存型的复制需要考虑的问题：在写的时候数据还在使用中。数据库快照。复制的时候，先拷贝快照，加载出来，这时候实现了和快照的时刻的同步；将快照之后的写操作记录下来并缓存，在快照开始再执行一遍写操作，这样开始追赶主节点的流程。

Slave从库在连接master主库的时候，master会进行内存快照，然后把整个快照文件发送给master。当slave和master断开了连接之后，重新连接时需要重新获取整个master的内存快照，slave所有数据全部清除，然后重新建立整个内存表。

相对于磁盘型内存库，内存性没有增量复制的概念，无法在存储位置上一一对应。

存储命令：
- save 同步保存到磁盘中

### 持久化机制：快照snapshot
将内存数据以二进制方式保存在快照文件中。
- 自动保存：通过检测修改频率，可以定时进行保存。或者检测时间区间内数据发生了多少次变化就进行一次保存；快照会不断覆盖。
- 父子进程：需要快照时，开启子进程来将内存内容写入临时文件；父进程继续处理业务请求。此时，系统为父进程创建页面副本，从而防止子进程在进行快照的过程中写入快照的数据不要发生变化。

### 语句追加aof
写命令写到aof文件中，把收到的写命令缓存起来，保证子进程重写失败的时候不会出现问题。

## 计算框架的容错
程序中的问题：【**有经验的程序员**】会在可能出错的地方抛出一个异常；


## 负载均衡
哈希法均衡；
