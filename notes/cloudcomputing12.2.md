

## CAP理论
基本需求：写要正确，读要正确
- 机制1 强一致性
保持内容一致，不允许消息丢失，各个节点同步。任何一个节点上操作了一个数据，其他节点上都对这个数据加锁，然后同步。

存在问题显然是效率低。要等到消息传到所有的节点才能用。并且会存在短板问题。单一节点太慢，整体都慢；单一节点失效，整体失效。

- 一致性
1. 强一致性
任何节点任何时间数据都是一致的。比如机制1.读简单，从任意单一节点读。
2. 最终一致性
允许出现有一段时间，各个节点上的数据是不一样的。只需要在这段时间之后最终保持一致。系统提供工具确保读写一致。读起来复杂一些，需要从多个节点中读并且进行判定。
3. one
常见于热备份的情况。

- 机制2：Quorum protocol 最终一致性
    - N 存储数据的节点数
    - W 在put请求中成功完成写操作的节点
    - R 在get请求中成功完成读操作的节点
    - W+R>N, W>N/2
超过一半的反馈到来(W>N/2)就允许了。之前有短板问题的时候，因为我们的节点是弹性变化的，可能在一直增长，这带来的问题是可能导致越增加越慢。
这样只等超过一半，相当于只需要等第K快的就可以了。

注意，没改过来的节点不意味着不用改了，而是说我这次先不等你了，我的锁已经放开了，没改过来的节点后面再慢慢改（有日志等工具，确保一定会改回来）。

- 举例：N=3
这时发生一个写操作，把所有的value从1变成2.
    - 强一致性：W=3，所有的都变成2，读的时候从任意一个节点读都可以，故R=1（意味着只需要读一个就能读到正确的节点）。
    - quorum：W=2就可以。这时候有两个节点value=2，还剩一个value=1。那么怎么读呢？由于规定了W+R>N，所以这时候至少应该令R=2，也就是说，我只要从所有节点中读至少2个，那么这2个中一定有一个正确的（更新后的，value=2）。至于怎么找正确的，可以利用标记，时间戳、版本号等。

- 对比：

总的来说，强一致性读快，最终一致性写快。要考虑业务的读写规模的对比。另外也要考虑到读操作天然比写操作要快。

架构设计很重要的一环是实现机制的设计，实现机制要求能够应对各种情况。保障数据准确性，保证效率，保证实现手段简单。

## 主从机制
- 一主多从结构
之前常见的master和data的也是主从机制，主节点管理，从节点工作。但是不是这里谈到的。

- 数据库主从分离
这里说的主节点处理核心工作。

单一库负载压力太大，需要多个库来分摊。

读库的分摊和写库的分摊。适用于读多写少的应用场景。
- 控制策略1 半同步复制

读请求和从库交互，写请求和主库交互。从库和主库之间交互。

- 控制策略2 中间件控制

写请求到来的时候在中间件上进行一个记录，先写主库，然后同步从库。主库的写完成的时候要给中间件反馈。

读请求岛来的时候先从中间件上过一下，看看有没有对应的写，如果有，如果没有。

- 控制策略3 缓存策略

写请求记录到相应的缓存中去，缓存容量有限，它只存放数据的标识类信息（如主键）。而中间件中可以自行设计，例如可以保存这一次写的内容。主库再把数据交给从库。

## Paxos 共识模式
以上都是有主控的方式。

分布式系统中不同节点的通信方式，包括消息传递，共享内存等。

全局时钟的问题

## PBFT 实用的拜占庭容错算法
