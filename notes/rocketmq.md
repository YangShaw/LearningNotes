
<!-- TOC -->

- [1. 基础知识](#1-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86)
  - [1.1. 消息队列](#11-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97)
    - [1.1.1. 作用](#111-%e4%bd%9c%e7%94%a8)
    - [1.1.2. 缺点](#112-%e7%bc%ba%e7%82%b9)
    - [1.1.3. 对比](#113-%e5%af%b9%e6%af%94)
    - [1.1.4. 消息队列高可用性（解决缺点1）](#114-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7%e8%a7%a3%e5%86%b3%e7%bc%ba%e7%82%b91)
      - [1.1.4.1. ***RabbitMQ***](#1141-rabbitmq)
        - [1.1.4.1.1. 单机模式](#11411-%e5%8d%95%e6%9c%ba%e6%a8%a1%e5%bc%8f)
        - [1.1.4.1.2. 普通集群（无高可用性）](#11412-%e6%99%ae%e9%80%9a%e9%9b%86%e7%be%a4%e6%97%a0%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7)
        - [1.1.4.1.3. 镜像集群（高可用性）](#11413-%e9%95%9c%e5%83%8f%e9%9b%86%e7%be%a4%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7)
      - [1.1.4.2. ***Kafka***](#1142-kafka)
        - [1.1.4.2.1. Kafka的HA机制](#11421-kafka%e7%9a%84ha%e6%9c%ba%e5%88%b6)
    - [1.1.5. 消息队列的幂等性（不重复消费）](#115-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%b9%82%e7%ad%89%e6%80%a7%e4%b8%8d%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9)
    - [1.1.6. 消息队列的可靠性（不丢失消息）](#116-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%8f%af%e9%9d%a0%e6%80%a7%e4%b8%8d%e4%b8%a2%e5%a4%b1%e6%b6%88%e6%81%af)
      - [1.1.6.1. RabbitMQ](#1161-rabbitmq)
        - [1.1.6.1.1. 生产者丢失](#11611-%e7%94%9f%e4%ba%a7%e8%80%85%e4%b8%a2%e5%a4%b1)
        - [1.1.6.1.2. RabbitMQ丢失](#11612-rabbitmq%e4%b8%a2%e5%a4%b1)
        - [1.1.6.1.3. 消费端丢失](#11613-%e6%b6%88%e8%b4%b9%e7%ab%af%e4%b8%a2%e5%a4%b1)
    - [1.1.7. 消息的顺序性](#117-%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%80%a7)
      - [1.1.7.1. RabbitMQ](#1171-rabbitmq)
        - [1.1.7.1.1. 错误场景](#11711-%e9%94%99%e8%af%af%e5%9c%ba%e6%99%af)
        - [1.1.7.1.2. 解决方案](#11712-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
      - [1.1.7.2. Kafka](#1172-kafka)
        - [1.1.7.2.1. 错误场景](#11721-%e9%94%99%e8%af%af%e5%9c%ba%e6%99%af)
        - [1.1.7.2.2. 解决方案](#11722-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
    - [1.1.8. 消息队列的延时和失效问题，消息积压问题](#118-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%bb%b6%e6%97%b6%e5%92%8c%e5%a4%b1%e6%95%88%e9%97%ae%e9%a2%98%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98)
    - [1.1.9. 消息队列的架构设计思路](#119-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af)
  - [1.2. RocketMQ的相关知识](#12-rocketmq%e7%9a%84%e7%9b%b8%e5%85%b3%e7%9f%a5%e8%af%86)
    - [1.2.1. 解耦](#121-%e8%a7%a3%e8%80%a6)
    - [1.2.2. 削峰](#122-%e5%89%8a%e5%b3%b0)
    - [1.2.3. 消息模式](#123-%e6%b6%88%e6%81%af%e6%a8%a1%e5%bc%8f)
    - [1.2.4. 事务处理](#124-%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86)
- [2. 开发者指南](#2-%e5%bc%80%e5%8f%91%e8%80%85%e6%8c%87%e5%8d%97)
  - [2.1. 基本概念](#21-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
    - [2.1.1. Message Model](#211-message-model)
    - [2.1.2. Topic](#212-topic)
    - [2.1.3. Broker Server](#213-broker-server)
    - [2.1.4. Name Server](#214-name-server)
    - [2.1.5. Pull / Push](#215-pull--push)
    - [2.1.6. Producer Group](#216-producer-group)
    - [2.1.7. Consumer Group](#217-consumer-group)
    - [2.1.8. Message](#218-message)
    - [2.1.9. Tag](#219-tag)
  - [特性](#%e7%89%b9%e6%80%a7)
    - [订阅与发布](#%e8%ae%a2%e9%98%85%e4%b8%8e%e5%8f%91%e5%b8%83)
    - [消息顺序](#%e6%b6%88%e6%81%af%e9%a1%ba%e5%ba%8f)
    - [消息过滤](#%e6%b6%88%e6%81%af%e8%bf%87%e6%bb%a4)
    - [消息可靠性](#%e6%b6%88%e6%81%af%e5%8f%af%e9%9d%a0%e6%80%a7)
    - [至少一次](#%e8%87%b3%e5%b0%91%e4%b8%80%e6%ac%a1)
    - [回溯消费](#%e5%9b%9e%e6%ba%af%e6%b6%88%e8%b4%b9)
    - [事务消息](#%e4%ba%8b%e5%8a%a1%e6%b6%88%e6%81%af)
    - [定时消息](#%e5%ae%9a%e6%97%b6%e6%b6%88%e6%81%af)
    - [消息重试](#%e6%b6%88%e6%81%af%e9%87%8d%e8%af%95)
    - [消息重投](#%e6%b6%88%e6%81%af%e9%87%8d%e6%8a%95)
    - [流量控制](#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
      - [生产者流量控制](#%e7%94%9f%e4%ba%a7%e8%80%85%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
      - [消费者流量控制](#%e6%b6%88%e8%b4%b9%e8%80%85%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
    - [死信队列](#%e6%ad%bb%e4%bf%a1%e9%98%9f%e5%88%97)
  - [架构设计](#%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1)
    - [技术架构](#%e6%8a%80%e6%9c%af%e6%9e%b6%e6%9e%84)
      - [Producer](#producer)
      - [Consumer](#consumer)
      - [NameServer](#nameserver)
      - [BrokerServer](#brokerserver)
    - [部署架构](#%e9%83%a8%e7%bd%b2%e6%9e%b6%e6%9e%84)
      - [网络部署](#%e7%bd%91%e7%bb%9c%e9%83%a8%e7%bd%b2)
  - [设计-消息存储](#%e8%ae%be%e8%ae%a1-%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8)
    - [消息存储整体架构](#%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84)
- [部署笔记](#%e9%83%a8%e7%bd%b2%e7%ac%94%e8%ae%b0)
  - [quick start](#quick-start)
    - [安装包](#%e5%ae%89%e8%a3%85%e5%8c%85)
    - [demo运行](#demo%e8%bf%90%e8%a1%8c)
    - [问题解决](#%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3)
    - [一些指令](#%e4%b8%80%e4%ba%9b%e6%8c%87%e4%bb%a4)
      - [nohup](#nohup)
      - [tail](#tail)

<!-- /TOC -->

# 1. 基础知识

## 1.1. 消息队列
参考资料：https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md

### 1.1.1. 作用
解耦，异步，削峰。在特殊场景下有其对应的好处。

### 1.1.2. 缺点
- 系统可用性降低。系统引入的外部依赖越多，越容易出现问题。
- 系统复杂度提高。消息是否丢失？是否有重复消费？怎么确保消息传递的顺序性？
- 一致性问题。

### 1.1.3. 对比
Kafka， ActiveMQ， RabbitMQ， RocketMQ

### 1.1.4. 消息队列高可用性（解决缺点1）
这个问题在不同的MQ中，会有不同的解决方案。

#### 1.1.4.1. ***RabbitMQ***
基于主从结构做高可用性（而非分布式）

##### 1.1.4.1.1. 单机模式
demo级别，生产中不会使用这个模式

##### 1.1.4.1.2. 普通集群（无高可用性）
多台机器上启动MQ，你创建的Queue只会放在一个RabbitMQ的实例上，但是每个实例都会同步queue的元数据。你所在的实例A如果需要向实例B中拉取数据（你掌握每个queue的元数据，你知道需要的数据位于B上），那么就A向B发送请求，获取数据之后再发送给消费者。

缺点在于：
- mq内部产生大量的数据传输。
- 可用性没有保障。存储queue的实例如果宕机，数据就丢失了。

这个集群是非常朴素的方式连接起来的，彼此之间实际上并没有什么关联，跟分布式没关系。消费者随机分配实例进行连接，则有实例间拉取数据的开销；消费者固定连接queue所在实例，则有单个实例性能瓶颈问题。

存放queue的实例宕机，若开启了消息持久化功能，则数据未必会丢，但是也得等到实例恢复了，才能继续拉取数据。

> 这个方案主要用来提高吞吐量，跟高可用性没有什么关系。

##### 1.1.4.1.3. 镜像集群（高可用性）
镜像模式，顾名思义，queue的消息会存在于多个实例上。生产者发送的消息首先交个一个实例，然后同步到每个实例上。所以消费者无论连接到哪一个实例都可以直接获取到数据。这样就不怕某一个机器宕机了。数据总是能找到的。

缺点在于：
- 消息要同步到所有机器上，开销太大
- 不是分布式的，不能线性扩展你的queue。？？


#### 1.1.4.2. ***Kafka***

- kafka的架构：分布式，由多个broker组成（节点）。创建一个topic，每个topic的数据可以被分成多个partition，每个partition存放数据的一部分，每个partition也可以存放在不同的broker上。从而，每个topic的数据是分散在多个机器上的。

##### 1.1.4.2.1. Kafka的HA机制
> HA：High Availability

即复制品机制（replica）。每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。所有的副本会选举一个leader出来，生产和消费都只和leader打交道，其他的follower相当于只负责备份的功能。这意味着不需要考虑follower的数据一致性问题，只需要leader负责保证他们相一致，但不需要即时的确保同步。Kafka会均匀地把所有的副本分布在不同的机器上，来提高容错性。

这样当某个broker宕机的时候，可以找这个broker中存储的partition对应的副本。如果这个broker包含某个partition的leader，那么就从它的follower中选择一个leader出来。

### 1.1.5. 消息队列的幂等性（不重复消费）

> 重复消费不可怕，只需要确保幂等性

- 重复消费

Kafka会通过offset序号来记录消费者消费到哪一条数据了。消费过的offset会被提交和记录到zookeeper中。但如果提交失败，则可能会出现重复消费，导致有些数据重复读取了。

- 幂等性

即使得到了若干条重复的数据，我们可以在使用的时候确保不要发生重复使用的情况。
解决方案譬如：
1. 写库的时候，先根据主键查一下。
2. 写redis，redis本身是set，天然幂等性。
3. 生产者发送每条数据的时候，加一个全局唯一的id，每次消费的时候根据id去redis里面查一查。这样来确保不要重复处理相同的消息即可。
4. 基于数据库的唯一键约束来自动阻止重复数据的插入。

### 1.1.6. 消息队列的可靠性（不丢失消息）

#### 1.1.6.1. RabbitMQ
三种消息丢失的情况：消息传入过程中被生产者弄丢；RabbitMQ收到消息，还没被消费自己弄丢；消费者弄丢；

##### 1.1.6.1.1. 生产者丢失
- 事务机制
使用事务功能，在发送数据之前开启RabbitMQ事务再发送消息。如果未被接收到，则生产者会异常报错，从而可以回滚事务，以重试。若收到了消息，则提交事务。

- confirm机制
每次写的消息分配一个唯一的id，成功写入会回传一个ack消息。如果没成功接收，会回调一个nack接口。如果长时间未接收到回调，可以重发。

- 区别

事务机制是同步的，提交一个事务之后会阻塞在那里。confirm机制是异步的，在接收到消息之后再异步回调这个接口，这期间不影响其他消息的收发。生产者一般都使用confirm机制。

##### 1.1.6.1.2. RabbitMQ丢失
需要开启RabbitMQ的持久化，消息写入之后会持久化到磁盘中。唯一可能造成丢失的情况：持久化之前数据就丢失了。这个概率很小。
- 为了避免这个情况，可以结合confirm机制，只有消息被持久化之后，才回传ack消息。

两个步骤：
1. 创建queue的时候设置持久化，这会持久化queue的元数据；
2. 将消息设置为持久化，queue的内容会存储到磁盘上。

##### 1.1.6.1.3. 消费端丢失
关闭RabbitMQ的自动ack，让自己在代码确保处理完数据之后，才发送ack。

### 1.1.7. 消息的顺序性

#### 1.1.7.1. RabbitMQ
##### 1.1.7.1.1. 错误场景
生产者按顺序发送了若干条数据，压入RabbitMQ的同一个内存队列中，不同的消费者同时消费这个队列中的数据，但消费者完成消费的顺序和生产者存入的顺序不一致。

##### 1.1.7.1.2. 解决方案
？没看懂

#### 1.1.7.2. Kafka
##### 1.1.7.2.1. 错误场景
消费者从partition中按照顺序取出来数据，但是之后可能会使用多个线程并发处理消息。多个线程并发的时候，顺序可能会错乱。

##### 1.1.7.2.2. 解决方案
具有相同key的数据都存储到同一个内存queue中，对于N个线程，每个线程分别消费一个内存queue

### 1.1.8. 消息队列的延时和失效问题，消息积压问题

### 1.1.9. 消息队列的架构设计思路
- 可扩展性要好，所以要分布式，从而方便增加吞吐量和容量。参照Kafka，broker-topic-partition，如果现有资源不够用了，就给topic增加partition，做数据迁移，增加机器。
- 持久化存储。那么mq的数据要落盘。顺序落盘可以保证顺序读写，这样在取数据的时候就不用对磁盘内容进行随机访问。磁盘擅长顺序读写，这也是Kafka的思路。
- 可用性要好。仍然参照Kafka的思路，多个副本进行存储（冗余确保宕机不影响）-leader&follower的机制来方便生产者和消费者读写-leader宕机后重新选举。
- （卡夫卡牛逼！）

## 1.2. RocketMQ的相关知识

参考资料：https://blog.csdn.net/qq_34462387/article/details/86562856

### 1.2.1. 解耦
用消息队列作为中间件
- 订单系统向mq写入订单消息，就返回用户下单成功；
- 库存系统订阅mq中的订单消息，在进行相应的库存操作。

由是，加入在下单的时候库存系统不能正常使用，也不影响下单操作。我们只需要确保中间件的正常工作就可以了。库存系统可以在正常的时候去和消息队列进行交互，从而实现了解耦合。

> 想到一个疑问，如何确保一致性？在库存系统还未修改的时候，订单系统是否可以对同一个库存进行操作？

### 1.2.2. 削峰
面对可能到来的流量突增活动（秒杀等），需要在应用前端增加消息队列。
- 用户请求写入mq；
- 秒杀业务处理系统根据规则从mq中读取请求，来进行后续的判断。

- 用户的请求服务器接收后，直接写入mq；如果超出了mq的容量，则抛弃请求或者跳转到错误界面（秒杀失败？）
  
### 1.2.3. 消息模式
1. 点对点发布 两个客户端一一对应，互相收发，通过mq作为中间件
2. 发布-订阅模式

### 1.2.4. 事务处理



# 2. 开发者指南

中文文档：https://github.com/apache/rocketmq/tree/master/docs/cn

## 2.1. 基本概念

### 2.1.1. Message Model
- Producer 生产者

业务系统里面产生的信息发送到Broker服务器。发送的方式包括**同步，异步，顺序，单向**。
- Broker 消息存储

Broker在实际部署的时候会对应一台服务器。每个Broker可以存储多个topic的信息，每个topic的信息也可以分块存储在不同的Broker上。
- Consumer 消费者

一般是后台系统负责异步的消费信息。消费者也是从Broker中获取信息。两种方式：pull、push。

### 2.1.2. Topic
一类消息的集合。每个Topic包含若干条信息，每条消息只能属于同一个Topic。Topic是RocketMQ进行消息订阅的基本单位。（类似Kafka？）

### 2.1.3. Broker Server
就是消息队列的核心，消息中转，负责消息的存储、转发。接收消息并存储，以及为消费者拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移offset、topic、队列消息等。

### 2.1.4. Name Server
名称服务，充当路由消息的提供者。通过Name来查找各个topic对应的Broker IP的列表，相当于存储的元数据？多个Name Server实例组成集群，但是没有信息交换，互相独立。

### 2.1.5. Pull / Push
- pull的方式主动权由应用控制
- push的方式由Broker主动推送，实时性较高

### 2.1.6. Producer Group
生产者群组，同一类Producer的集合。属于同一类的Producer，发送的消息属于同一类，发送的逻辑也一致。如果发送的是事务消息，原始生产者在发送之后崩溃，则Broker服务器会找到同一Producer Group的其他生产者实例来提交或回溯消费。

### 2.1.7. Consumer Group
消费者群组，同理，同一类，消费逻辑一致。消费者群组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。同一Consumer Group中的消费者实例必须要订阅完全相同topic。两种消费方式：集群消费Clustring和广播消费Broadcasting。

- Clustring

同一Consumer Group的每个Consumer实例平均分摊消息。

- Broadcasting

同一Consumer Group的每个Consumer实例都接收全量的消息。

- 普通顺序消息 Normal Ordered Message

Consumer通过同一个消费队列接收到的消息是有顺序的，不同消息队列收到的消息可能是无顺序的。

- 严格顺序消息 Strictly Ordered Message

Consumer收到的所有消息都是严格有序的。

### 2.1.8. Message
生产和消费数据的最小单位，每条消息必须属于一个主题。每条消息都有唯一的一个Message ID，并且可以携带具有业务标识的key。系统提供了通过Message ID和key查询消息的功能。

### 2.1.9. Tag
用来在同一个topic下再细分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一个topic下细分tag。消费者可以根据tag来实现对topic下面的不同的子主题的不同消费逻辑，从而实现更好的扩展性和定制化。


## 特性

### 订阅与发布
- 发布：某个Producer向某个topic发送消息。
- 订阅：某个Consumer关注某个topic中带有某些tag的消息，进而从该topic消费数据。

### 消息顺序
- 全局顺序：对于一个指定的topic，所有的消息按照严格的先入先出的顺序进行发布和消费。适用于对性能要求不高，并且所有的消息严格按照FIFO原则发布和消费的场景。
- 分区顺序：对于一个指定的topic，消息按照sharding key进行区块分区。同一个分区内的消息按照FIFO。sharding key是专门用来分区的关键字段，和消息的key是两个概念。适用于性能要求高的场景。

### 消息过滤
Tag是过滤的一种条件，也可以自定义过滤的条件。

在Broker端实现，好处在于减少了向Consumer的无用消息的传输，坏处是增加了Broker的负担。

### 消息可靠性
- 硬件问题，可立即恢复，RocketMQ可以保证消息不丢或者仅丢失少量。
- 单点故障（机器无法开机，磁盘设备损坏），且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ的异步复制（冗余）机制可以确保99%的消息不丢。同步双写技术可以完全避免单点故障造成的损失，但同步会影响性能。**适用于对消息可靠性需求极高的场合**。

### 至少一次
每个消息必须投递一次。Consumer将消息pull到本地且消费完成之后，才向服务器返回ack。也就是说，如果没有消费，则一定不会返回ack消息。

### 回溯消费
Broker在向Consumer投递成功消息后，消息仍然需要保留。重新消费一般都是按照时间维度。RocketMQ支持按照时间回溯消费，精确到ms。

### 事务消息
Transactional Message是指应用本地事务和发送消息操作可以被定义到全局事务中。

### 定时消息
延迟队列中的消息会在定时的delay之后被投递给topic。在broker中配置它的属性messageDelayLevel（这不是topic的属性）。当level==0的时候是非延迟消息。

定时消息会暂存在与目标topic对应的临时topic中，并且会根据延迟级别存入对应的queue中。每个queue中只存放相同延迟的消息，从而确保具有相同发送延迟的消息能够被顺序消费。broker会调度的消费这些临时topic中的队列，来把消息写入真实的topic。

如果发送定时消息，那么有存入临时topic和真实topic两次写入过程，都会计数，所以发送数量、tps都会变高。

### 消息重试
Consumer消费失败的两种情况:
- 消息本身的原因导致消费失败（反序列化错误，消息数据错误）；此时跳过这条消息，再消费其他消息；当前消息定时重试，如延时10s；
- 依赖的下游应用服务不可用导致消费失败（例如db连接错误，外系统网络错误等）；此时其他的消息一般也不能消费，所以让应用休眠30s，从而减轻broker重试消息的压力。

重试的消息会存放在重试队列。重试队列针对ConsumerGroup而设立，而非topic。

### 消息重投
生产者发送消息的时候，同步消息发送失败会重投；异步消息发送失败会重试；oneway没有任何保证。

消息重投能保证消息尽可能的发送成功、不丢失，但可能造成消息重复。一般，在消息量大、网络抖动时，消息重复就是大概率事件。另外，Producer主动重发、Consumer负载变化也会导致重复消息。

重投策略：

### 流量控制

#### 生产者流量控制
因为broker处理能力达到瓶颈。生产者的流控，不会尝试消息重投。
- commitLog文件被锁超时
- broker为异步刷盘的主机，且……
- broker每隔10ms检查send请求队列头部请求的等待时间
- broker通过拒绝send请求方式实现流量控制
  
#### 消费者流量控制
因为消费能力达到瓶颈。消费者流控的结果是降低拉取消息的频率。
- 消费者本地缓存消息数超过拉取的阈值
- 消费者本地缓存消息的大小超过阈值
- 消费者本地缓存消息的跨度超过阈值

### 死信队列
消息消费失败，会进行消息重试；

达到最大重试次数，则表明消费者在正常情况下无法正确的消费该消息。这类消息被称为死信消息（Dead-Letter Message）。


## 架构设计

### 技术架构

#### Producer
支持分布式集群方式部署。通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。

#### Consumer
支持分布式集群方式部署。两种消费模式pull, push。支持集群和广播方式的消费，提供实时的消息订阅机制。

#### NameServer
是一个对topic路由信息的注册中心，支持Broker的动态注册与发现。类似于zookeeper在Dubbo中的功能。
- 管理Broker，接收Broker集群的注册信息，并保存下来作为路由信息的基本数据，提供心跳检测机制，检查Broker的存活情况
- 路由信息管理，每个NameServer会保存关于Broker集群的整个路由信息，和用于客户端查询的队列信息。

Producer和Consumer通过查询NameServer来知道去哪个Broker中找到需要的路由信息（目标消息在何处），来进行消息的投递和消费。

每个NameServer实例上都保存完整的路由信息，属于集群部署的。

#### BrokerServer
Broker负责消息的存储、投递、查询和服务的高可用性。包含子模块：
- Remoting Module：整个Broker的实体，负责处理来自客户端的请求。
- Client Manager：管理客户端（包括Producer和Consumer）和维护Consumer的topic订阅信息
- Store Service：提供API接口，来方便消息存储到物理硬盘，以及查询消息
- HA Service：提供Master Broker和Slave Broker之间的数据同步功能
- Index Service：根据特定的Message Key对投递到Broker的消息进行索引服务，便于快速查询

<!-- ![部署架构](https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_architecture_3.png) -->

### 部署架构

#### 网络部署
- NameServer

无状态的节点，集群部署
- Broker

Master和Slave节点是一对多的关系。对应的一组，BrokerName相同，BrokerId为0的是Master节点，其余为Slave节点。

每个Broker与NameServer集群中的**所有节点**都建立长连接，定时注册topic信息到所有的NameServer。
- Producer

与**随机一个**NameServer中的节点建立长连接，定期从中获取topic的路由信息；

向提供topic服务的Master节点建立长连接，定期发送心跳；

Producer节点是无状态的，可以集群部署。

- Consumer


## 设计-消息存储

提纲：
- 消息存储整体架构
- PageCache与Mmap内存映射
- 两种刷盘方式

### 消息存储整体架构




# 部署笔记

## quick start
> 文档：https://rocketmq.apache.org/docs/quick-start/

### 安装包
- JDK 1.8
- Git
- Maven

1. 官网下载Maven最新版本

2. 安装在/usr/local/文件夹中

  解压指令：
  ```shell
  tar -zxvf [filename]
  ```
3. 添加环境变量
  打开配置文件
  ```shell
  vim /etc/profile
  ```
  增加路径
  ```
  MAVEN_HOME=/usr/local/maven/apache-maven-3.6.3
  export PATH=${MAVEN_HOME}/bin:${PATH}
  ```
  执行
  ```shell
  source /etc/profile
  ```

### demo运行
根据文档中的步骤执行example的Producer和Consumer

### 问题解决
- Broker.log文件不存在

1. 需要安装jdk，并配置JAVA_HOME环境变量。之前系统预装的openjdk不靠谱。

参见 https://blog.csdn.net/weixin_38384296/article/details/102883108

2. 服务器的内存资源不足以支持RocketMQ的默认配置，需要修改两个配置文件：

参见 https://blog.csdn.net/weixin_38384296/article/details/102884039 中的[其他]部分。

### 一些指令

#### nohup
no hang up 不挂断，执行的指令在终端关闭后仍会运行。

& 是在后台运行的意思。但当用户挂起的时候，命令自动也跟着退出。

执行命令后，显示：
```shell
nohup: input and appending output to ‘nohup.out’
```

#### tail
显示文件最尾部的内容
```shell
tail -f [filename]
```



