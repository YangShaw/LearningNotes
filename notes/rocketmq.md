
<!-- TOC -->

- [1. 基础知识](#1-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86)
  - [1.1. 消息队列](#11-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97)
    - [1.1.1. 作用](#111-%e4%bd%9c%e7%94%a8)
    - [1.1.2. 缺点](#112-%e7%bc%ba%e7%82%b9)
    - [1.1.3. 对比](#113-%e5%af%b9%e6%af%94)
    - [1.1.4. 消息队列高可用性（解决缺点1）](#114-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7%e8%a7%a3%e5%86%b3%e7%bc%ba%e7%82%b91)
      - [1.1.4.1. ***RabbitMQ***](#1141-rabbitmq)
        - [1.1.4.1.1. 单机模式](#11411-%e5%8d%95%e6%9c%ba%e6%a8%a1%e5%bc%8f)
        - [1.1.4.1.2. 普通集群（无高可用性）](#11412-%e6%99%ae%e9%80%9a%e9%9b%86%e7%be%a4%e6%97%a0%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7)
        - [1.1.4.1.3. 镜像集群（高可用性）](#11413-%e9%95%9c%e5%83%8f%e9%9b%86%e7%be%a4%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7)
      - [1.1.4.2. ***Kafka***](#1142-kafka)
        - [1.1.4.2.1. Kafka的HA机制](#11421-kafka%e7%9a%84ha%e6%9c%ba%e5%88%b6)
    - [1.1.5. 消息队列的幂等性（不重复消费）](#115-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%b9%82%e7%ad%89%e6%80%a7%e4%b8%8d%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9)
    - [1.1.6. 消息队列的可靠性（不丢失消息）](#116-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%8f%af%e9%9d%a0%e6%80%a7%e4%b8%8d%e4%b8%a2%e5%a4%b1%e6%b6%88%e6%81%af)
      - [1.1.6.1. RabbitMQ](#1161-rabbitmq)
        - [1.1.6.1.1. 生产者丢失](#11611-%e7%94%9f%e4%ba%a7%e8%80%85%e4%b8%a2%e5%a4%b1)
        - [1.1.6.1.2. RabbitMQ丢失](#11612-rabbitmq%e4%b8%a2%e5%a4%b1)
        - [1.1.6.1.3. 消费端丢失](#11613-%e6%b6%88%e8%b4%b9%e7%ab%af%e4%b8%a2%e5%a4%b1)
    - [1.1.7. 消息的顺序性](#117-%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%80%a7)
      - [1.1.7.1. RabbitMQ](#1171-rabbitmq)
        - [1.1.7.1.1. 错误场景](#11711-%e9%94%99%e8%af%af%e5%9c%ba%e6%99%af)
        - [1.1.7.1.2. 解决方案](#11712-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
      - [1.1.7.2. Kafka](#1172-kafka)
        - [1.1.7.2.1. 错误场景](#11721-%e9%94%99%e8%af%af%e5%9c%ba%e6%99%af)
        - [1.1.7.2.2. 解决方案](#11722-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
    - [1.1.8. 消息队列的延时和失效问题，消息积压问题](#118-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%bb%b6%e6%97%b6%e5%92%8c%e5%a4%b1%e6%95%88%e9%97%ae%e9%a2%98%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b%e9%97%ae%e9%a2%98)
    - [1.1.9. 消息队列的架构设计思路](#119-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af)
  - [1.2. RocketMQ的相关知识](#12-rocketmq%e7%9a%84%e7%9b%b8%e5%85%b3%e7%9f%a5%e8%af%86)
    - [1.2.1. 解耦](#121-%e8%a7%a3%e8%80%a6)
    - [1.2.2. 削峰](#122-%e5%89%8a%e5%b3%b0)
    - [1.2.3. 消息模式](#123-%e6%b6%88%e6%81%af%e6%a8%a1%e5%bc%8f)
    - [1.2.4. 事务处理](#124-%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86)
- [2. 开发者指南](#2-%e5%bc%80%e5%8f%91%e8%80%85%e6%8c%87%e5%8d%97)
  - [2.1. 基本概念](#21-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
    - [2.1.1. Message Model](#211-message-model)
    - [2.1.2. Topic](#212-topic)
    - [2.1.3. Broker Server](#213-broker-server)
    - [2.1.4. Name Server](#214-name-server)
    - [2.1.5. Pull / Push](#215-pull--push)
    - [2.1.6. Producer Group](#216-producer-group)
    - [2.1.7. Consumer Group](#217-consumer-group)
    - [2.1.8. Message](#218-message)
    - [2.1.9. Tag](#219-tag)
  - [2.2. 特性](#22-%e7%89%b9%e6%80%a7)
    - [2.2.1. 订阅与发布](#221-%e8%ae%a2%e9%98%85%e4%b8%8e%e5%8f%91%e5%b8%83)
    - [2.2.2. 消息顺序](#222-%e6%b6%88%e6%81%af%e9%a1%ba%e5%ba%8f)
    - [2.2.3. 消息过滤](#223-%e6%b6%88%e6%81%af%e8%bf%87%e6%bb%a4)
    - [2.2.4. 消息可靠性](#224-%e6%b6%88%e6%81%af%e5%8f%af%e9%9d%a0%e6%80%a7)
    - [2.2.5. 至少一次](#225-%e8%87%b3%e5%b0%91%e4%b8%80%e6%ac%a1)
    - [2.2.6. 回溯消费](#226-%e5%9b%9e%e6%ba%af%e6%b6%88%e8%b4%b9)
    - [2.2.7. 事务消息](#227-%e4%ba%8b%e5%8a%a1%e6%b6%88%e6%81%af)
    - [2.2.8. 定时消息](#228-%e5%ae%9a%e6%97%b6%e6%b6%88%e6%81%af)
    - [2.2.9. 消息重试](#229-%e6%b6%88%e6%81%af%e9%87%8d%e8%af%95)
    - [2.2.10. 消息重投](#2210-%e6%b6%88%e6%81%af%e9%87%8d%e6%8a%95)
    - [2.2.11. 流量控制](#2211-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
      - [2.2.11.1. 生产者流量控制](#22111-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
      - [2.2.11.2. 消费者流量控制](#22112-%e6%b6%88%e8%b4%b9%e8%80%85%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6)
    - [2.2.12. 死信队列](#2212-%e6%ad%bb%e4%bf%a1%e9%98%9f%e5%88%97)
  - [2.3. 架构设计](#23-%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1)
    - [2.3.1. 技术架构](#231-%e6%8a%80%e6%9c%af%e6%9e%b6%e6%9e%84)
      - [2.3.1.1. Producer](#2311-producer)
      - [2.3.1.2. Consumer](#2312-consumer)
      - [2.3.1.3. NameServer](#2313-nameserver)
      - [2.3.1.4. BrokerServer](#2314-brokerserver)
    - [2.3.2. 部署架构](#232-%e9%83%a8%e7%bd%b2%e6%9e%b6%e6%9e%84)
      - [2.3.2.1. 网络部署](#2321-%e7%bd%91%e7%bb%9c%e9%83%a8%e7%bd%b2)
  - [2.4. 设计-消息存储](#24-%e8%ae%be%e8%ae%a1-%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8)
    - [2.4.1. 消息存储整体架构](#241-%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84)
      - [2.4.1.1. CommitLog](#2411-commitlog)
      - [2.4.1.2. ConsumeQueue](#2412-consumequeue)
      - [2.4.1.3. IndexFile](#2413-indexfile)
      - [存储方式](#%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f)
    - [页缓存和内存映射](#%e9%a1%b5%e7%bc%93%e5%ad%98%e5%92%8c%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84)
    - [消息刷盘](#%e6%b6%88%e6%81%af%e5%88%b7%e7%9b%98)
  - [设计-通信机制](#%e8%ae%be%e8%ae%a1-%e9%80%9a%e4%bf%a1%e6%9c%ba%e5%88%b6)
    - [Remoting通信类结构](#remoting%e9%80%9a%e4%bf%a1%e7%b1%bb%e7%bb%93%e6%9e%84)
    - [协议，编码解码](#%e5%8d%8f%e8%ae%ae%e7%bc%96%e7%a0%81%e8%a7%a3%e7%a0%81)
    - [消息的通信方式和流程](#%e6%b6%88%e6%81%af%e7%9a%84%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f%e5%92%8c%e6%b5%81%e7%a8%8b)
    - [Reactor多线程设计](#reactor%e5%a4%9a%e7%ba%bf%e7%a8%8b%e8%ae%be%e8%ae%a1)
      - [Netty](#netty)
  - [设计-消息过滤](#%e8%ae%be%e8%ae%a1-%e6%b6%88%e6%81%af%e8%bf%87%e6%bb%a4)
  - [设计-负载均衡](#%e8%ae%be%e8%ae%a1-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1)
    - [Producer发送消息时](#producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af%e6%97%b6)
    - [Consumer拉取消息时](#consumer%e6%8b%89%e5%8f%96%e6%b6%88%e6%81%af%e6%97%b6)
- [3. 部署笔记](#3-%e9%83%a8%e7%bd%b2%e7%ac%94%e8%ae%b0)
  - [3.1. quick start](#31-quick-start)
    - [3.1.1. 安装包](#311-%e5%ae%89%e8%a3%85%e5%8c%85)
    - [3.1.2. demo运行](#312-demo%e8%bf%90%e8%a1%8c)
    - [3.1.3. 问题解决](#313-%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3)
    - [3.1.4. 一些指令](#314-%e4%b8%80%e4%ba%9b%e6%8c%87%e4%bb%a4)
      - [3.1.4.1. nohup](#3141-nohup)
      - [3.1.4.2. tail](#3142-tail)

<!-- /TOC -->

# 1. 基础知识

## 1.1. 消息队列
参考资料：https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md

### 1.1.1. 作用
解耦，异步，削峰。在特殊场景下有其对应的好处。

### 1.1.2. 缺点
- 系统可用性降低。系统引入的外部依赖越多，越容易出现问题。
- 系统复杂度提高。消息是否丢失？是否有重复消费？怎么确保消息传递的顺序性？
- 一致性问题。

### 1.1.3. 对比
Kafka， ActiveMQ， RabbitMQ， RocketMQ

### 1.1.4. 消息队列高可用性（解决缺点1）
这个问题在不同的MQ中，会有不同的解决方案。

#### 1.1.4.1. ***RabbitMQ***
基于主从结构做高可用性（而非分布式）

##### 1.1.4.1.1. 单机模式
demo级别，生产中不会使用这个模式

##### 1.1.4.1.2. 普通集群（无高可用性）
多台机器上启动MQ，你创建的Queue只会放在一个RabbitMQ的实例上，但是每个实例都会同步queue的元数据。你所在的实例A如果需要向实例B中拉取数据（你掌握每个queue的元数据，你知道需要的数据位于B上），那么就A向B发送请求，获取数据之后再发送给消费者。

缺点在于：
- mq内部产生大量的数据传输。
- 可用性没有保障。存储queue的实例如果宕机，数据就丢失了。

这个集群是非常朴素的方式连接起来的，彼此之间实际上并没有什么关联，跟分布式没关系。消费者随机分配实例进行连接，则有实例间拉取数据的开销；消费者固定连接queue所在实例，则有单个实例性能瓶颈问题。

存放queue的实例宕机，若开启了消息持久化功能，则数据未必会丢，但是也得等到实例恢复了，才能继续拉取数据。

> 这个方案主要用来提高吞吐量，跟高可用性没有什么关系。

##### 1.1.4.1.3. 镜像集群（高可用性）
镜像模式，顾名思义，queue的消息会存在于多个实例上。生产者发送的消息首先交个一个实例，然后同步到每个实例上。所以消费者无论连接到哪一个实例都可以直接获取到数据。这样就不怕某一个机器宕机了。数据总是能找到的。

缺点在于：
- 消息要同步到所有机器上，开销太大
- 不是分布式的，不能线性扩展你的queue。？？


#### 1.1.4.2. ***Kafka***

- kafka的架构：分布式，由多个broker组成（节点）。创建一个topic，每个topic的数据可以被分成多个partition，每个partition存放数据的一部分，每个partition也可以存放在不同的broker上。从而，每个topic的数据是分散在多个机器上的。

##### 1.1.4.2.1. Kafka的HA机制
> HA：High Availability

即复制品机制（replica）。每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。所有的副本会选举一个leader出来，生产和消费都只和leader打交道，其他的follower相当于只负责备份的功能。这意味着不需要考虑follower的数据一致性问题，只需要leader负责保证他们相一致，但不需要即时的确保同步。Kafka会均匀地把所有的副本分布在不同的机器上，来提高容错性。

这样当某个broker宕机的时候，可以找这个broker中存储的partition对应的副本。如果这个broker包含某个partition的leader，那么就从它的follower中选择一个leader出来。

### 1.1.5. 消息队列的幂等性（不重复消费）

> 重复消费不可怕，只需要确保幂等性

- 重复消费

Kafka会通过offset序号来记录消费者消费到哪一条数据了。消费过的offset会被提交和记录到zookeeper中。但如果提交失败，则可能会出现重复消费，导致有些数据重复读取了。

- 幂等性

即使得到了若干条重复的数据，我们可以在使用的时候确保不要发生重复使用的情况。
解决方案譬如：
1. 写库的时候，先根据主键查一下。
2. 写redis，redis本身是set，天然幂等性。
3. 生产者发送每条数据的时候，加一个全局唯一的id，每次消费的时候根据id去redis里面查一查。这样来确保不要重复处理相同的消息即可。
4. 基于数据库的唯一键约束来自动阻止重复数据的插入。

### 1.1.6. 消息队列的可靠性（不丢失消息）

#### 1.1.6.1. RabbitMQ
三种消息丢失的情况：消息传入过程中被生产者弄丢；RabbitMQ收到消息，还没被消费自己弄丢；消费者弄丢；

##### 1.1.6.1.1. 生产者丢失
- 事务机制
使用事务功能，在发送数据之前开启RabbitMQ事务再发送消息。如果未被接收到，则生产者会异常报错，从而可以回滚事务，以重试。若收到了消息，则提交事务。

- confirm机制
每次写的消息分配一个唯一的id，成功写入会回传一个ack消息。如果没成功接收，会回调一个nack接口。如果长时间未接收到回调，可以重发。

- 区别

事务机制是同步的，提交一个事务之后会阻塞在那里。confirm机制是异步的，在接收到消息之后再异步回调这个接口，这期间不影响其他消息的收发。生产者一般都使用confirm机制。

##### 1.1.6.1.2. RabbitMQ丢失
需要开启RabbitMQ的持久化，消息写入之后会持久化到磁盘中。唯一可能造成丢失的情况：持久化之前数据就丢失了。这个概率很小。
- 为了避免这个情况，可以结合confirm机制，只有消息被持久化之后，才回传ack消息。

两个步骤：
1. 创建queue的时候设置持久化，这会持久化queue的元数据；
2. 将消息设置为持久化，queue的内容会存储到磁盘上。

##### 1.1.6.1.3. 消费端丢失
关闭RabbitMQ的自动ack，让自己在代码确保处理完数据之后，才发送ack。

### 1.1.7. 消息的顺序性

#### 1.1.7.1. RabbitMQ
##### 1.1.7.1.1. 错误场景
生产者按顺序发送了若干条数据，压入RabbitMQ的同一个内存队列中，不同的消费者同时消费这个队列中的数据，但消费者完成消费的顺序和生产者存入的顺序不一致。

##### 1.1.7.1.2. 解决方案
？没看懂

#### 1.1.7.2. Kafka
##### 1.1.7.2.1. 错误场景
消费者从partition中按照顺序取出来数据，但是之后可能会使用多个线程并发处理消息。多个线程并发的时候，顺序可能会错乱。

##### 1.1.7.2.2. 解决方案
具有相同key的数据都存储到同一个内存queue中，对于N个线程，每个线程分别消费一个内存queue

### 1.1.8. 消息队列的延时和失效问题，消息积压问题

### 1.1.9. 消息队列的架构设计思路
- 可扩展性要好，所以要分布式，从而方便增加吞吐量和容量。参照Kafka，broker-topic-partition，如果现有资源不够用了，就给topic增加partition，做数据迁移，增加机器。
- 持久化存储。那么mq的数据要落盘。顺序落盘可以保证顺序读写，这样在取数据的时候就不用对磁盘内容进行随机访问。磁盘擅长顺序读写，这也是Kafka的思路。
- 可用性要好。仍然参照Kafka的思路，多个副本进行存储（冗余确保宕机不影响）-leader&follower的机制来方便生产者和消费者读写-leader宕机后重新选举。
- （卡夫卡牛逼！）

## 1.2. RocketMQ的相关知识

参考资料：https://blog.csdn.net/qq_34462387/article/details/86562856

### 1.2.1. 解耦
用消息队列作为中间件
- 订单系统向mq写入订单消息，就返回用户下单成功；
- 库存系统订阅mq中的订单消息，在进行相应的库存操作。

由是，加入在下单的时候库存系统不能正常使用，也不影响下单操作。我们只需要确保中间件的正常工作就可以了。库存系统可以在正常的时候去和消息队列进行交互，从而实现了解耦合。

> 想到一个疑问，如何确保一致性？在库存系统还未修改的时候，订单系统是否可以对同一个库存进行操作？

### 1.2.2. 削峰
面对可能到来的流量突增活动（秒杀等），需要在应用前端增加消息队列。
- 用户请求写入mq；
- 秒杀业务处理系统根据规则从mq中读取请求，来进行后续的判断。

- 用户的请求服务器接收后，直接写入mq；如果超出了mq的容量，则抛弃请求或者跳转到错误界面（秒杀失败？）
  
### 1.2.3. 消息模式
1. 点对点发布 两个客户端一一对应，互相收发，通过mq作为中间件
2. 发布-订阅模式

### 1.2.4. 事务处理



# 2. 开发者指南

中文文档：https://github.com/apache/rocketmq/tree/master/docs/cn

## 2.1. 基本概念

### 2.1.1. Message Model
- Producer 生产者

业务系统里面产生的信息发送到Broker服务器。发送的方式包括**同步，异步，顺序，单向**。
- Broker 消息存储

Broker在实际部署的时候会对应一台服务器。每个Broker可以存储多个topic的信息，每个topic的信息也可以分块存储在不同的Broker上。
- Consumer 消费者

一般是后台系统负责异步的消费信息。消费者也是从Broker中获取信息。两种方式：pull、push。

### 2.1.2. Topic
一类消息的集合。每个Topic包含若干条信息，每条消息只能属于同一个Topic。Topic是RocketMQ进行消息订阅的基本单位。（类似Kafka？）

### 2.1.3. Broker Server
就是消息队列的核心，消息中转，负责消息的存储、转发。接收消息并存储，以及为消费者拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移offset、topic、队列消息等。

### 2.1.4. Name Server
名称服务，充当路由消息的提供者。通过Name来查找各个topic对应的Broker IP的列表，相当于存储的元数据？多个Name Server实例组成集群，但是没有信息交换，互相独立。

### 2.1.5. Pull / Push
- pull的方式主动权由应用控制
- push的方式由Broker主动推送，实时性较高

### 2.1.6. Producer Group
生产者群组，同一类Producer的集合。属于同一类的Producer，发送的消息属于同一类，发送的逻辑也一致。如果发送的是事务消息，原始生产者在发送之后崩溃，则Broker服务器会找到同一Producer Group的其他生产者实例来提交或回溯消费。

### 2.1.7. Consumer Group
消费者群组，同理，同一类，消费逻辑一致。消费者群组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。同一Consumer Group中的消费者实例必须要订阅完全相同topic。两种消费方式：集群消费Clustring和广播消费Broadcasting。

- Clustring

同一Consumer Group的每个Consumer实例平均分摊消息。

- Broadcasting

同一Consumer Group的每个Consumer实例都接收全量的消息。

- 普通顺序消息 Normal Ordered Message

Consumer通过同一个消费队列接收到的消息是有顺序的，不同消息队列收到的消息可能是无顺序的。

- 严格顺序消息 Strictly Ordered Message

Consumer收到的所有消息都是严格有序的。

### 2.1.8. Message
生产和消费数据的最小单位，每条消息必须属于一个主题。每条消息都有唯一的一个Message ID，并且可以携带具有业务标识的key。系统提供了通过Message ID和key查询消息的功能。

### 2.1.9. Tag
用来在同一个topic下再细分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一个topic下细分tag。消费者可以根据tag来实现对topic下面的不同的子主题的不同消费逻辑，从而实现更好的扩展性和定制化。


## 2.2. 特性

### 2.2.1. 订阅与发布
- 发布：某个Producer向某个topic发送消息。
- 订阅：某个Consumer关注某个topic中带有某些tag的消息，进而从该topic消费数据。

### 2.2.2. 消息顺序
- 全局顺序：对于一个指定的topic，所有的消息按照严格的先入先出的顺序进行发布和消费。适用于对性能要求不高，并且所有的消息严格按照FIFO原则发布和消费的场景。
- 分区顺序：对于一个指定的topic，消息按照sharding key进行区块分区。同一个分区内的消息按照FIFO。sharding key是专门用来分区的关键字段，和消息的key是两个概念。适用于性能要求高的场景。

### 2.2.3. 消息过滤
Tag是过滤的一种条件，也可以自定义过滤的条件。

在Broker端实现，好处在于减少了向Consumer的无用消息的传输，坏处是增加了Broker的负担。

### 2.2.4. 消息可靠性
- 硬件问题，可立即恢复，RocketMQ可以保证消息不丢或者仅丢失少量。
- 单点故障（机器无法开机，磁盘设备损坏），且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ的异步复制（冗余）机制可以确保99%的消息不丢。同步双写技术可以完全避免单点故障造成的损失，但同步会影响性能。**适用于对消息可靠性需求极高的场合**。

### 2.2.5. 至少一次
每个消息必须投递一次。Consumer将消息pull到本地且消费完成之后，才向服务器返回ack。也就是说，如果没有消费，则一定不会返回ack消息。

### 2.2.6. 回溯消费
Broker在向Consumer投递成功消息后，消息仍然需要保留。重新消费一般都是按照时间维度。RocketMQ支持按照时间回溯消费，精确到ms。

### 2.2.7. 事务消息
Transactional Message是指应用本地事务和发送消息操作可以被定义到全局事务中。

### 2.2.8. 定时消息
延迟队列中的消息会在定时的delay之后被投递给topic。在broker中配置它的属性messageDelayLevel（这不是topic的属性）。当level==0的时候是非延迟消息。

定时消息会暂存在与目标topic对应的临时topic中，并且会根据延迟级别存入对应的queue中。每个queue中只存放相同延迟的消息，从而确保具有相同发送延迟的消息能够被顺序消费。broker会调度的消费这些临时topic中的队列，来把消息写入真实的topic。

如果发送定时消息，那么有存入临时topic和真实topic两次写入过程，都会计数，所以发送数量、tps都会变高。

### 2.2.9. 消息重试
Consumer消费失败的两种情况:
- 消息本身的原因导致消费失败（反序列化错误，消息数据错误）；此时跳过这条消息，再消费其他消息；当前消息定时重试，如延时10s；
- 依赖的下游应用服务不可用导致消费失败（例如db连接错误，外系统网络错误等）；此时其他的消息一般也不能消费，所以让应用休眠30s，从而减轻broker重试消息的压力。

重试的消息会存放在重试队列。重试队列针对ConsumerGroup而设立，而非topic。

### 2.2.10. 消息重投
生产者发送消息的时候，同步消息发送失败会重投；异步消息发送失败会重试；oneway没有任何保证。

消息重投能保证消息尽可能的发送成功、不丢失，但可能造成消息重复。一般，在消息量大、网络抖动时，消息重复就是大概率事件。另外，Producer主动重发、Consumer负载变化也会导致重复消息。

重投策略：

### 2.2.11. 流量控制

#### 2.2.11.1. 生产者流量控制
因为broker处理能力达到瓶颈。生产者的流控，不会尝试消息重投。
- commitLog文件被锁超时
- broker为异步刷盘的主机，且……
- broker每隔10ms检查send请求队列头部请求的等待时间
- broker通过拒绝send请求方式实现流量控制
  
#### 2.2.11.2. 消费者流量控制
因为消费能力达到瓶颈。消费者流控的结果是降低拉取消息的频率。
- 消费者本地缓存消息数超过拉取的阈值
- 消费者本地缓存消息的大小超过阈值
- 消费者本地缓存消息的跨度超过阈值

### 2.2.12. 死信队列
消息消费失败，会进行消息重试；

达到最大重试次数，则表明消费者在正常情况下无法正确的消费该消息。这类消息被称为死信消息（Dead-Letter Message）。


## 2.3. 架构设计

### 2.3.1. 技术架构

#### 2.3.1.1. Producer
支持分布式集群方式部署。通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。

#### 2.3.1.2. Consumer
支持分布式集群方式部署。两种消费模式pull, push。支持集群和广播方式的消费，提供实时的消息订阅机制。

#### 2.3.1.3. NameServer
是一个对topic路由信息的注册中心，支持Broker的动态注册与发现。类似于zookeeper在Dubbo中的功能。
- 管理Broker，接收Broker集群的注册信息，并保存下来作为路由信息的基本数据，提供心跳检测机制，检查Broker的存活情况
- 路由信息管理，每个NameServer会保存关于Broker集群的整个路由信息，和用于客户端查询的队列信息。

Producer和Consumer通过查询NameServer来知道去哪个Broker中找到需要的路由信息（目标消息在何处），来进行消息的投递和消费。

每个NameServer实例上都保存完整的路由信息，属于集群部署的。

#### 2.3.1.4. BrokerServer
Broker负责消息的存储、投递、查询和服务的高可用性。包含子模块：
- Remoting Module：整个Broker的实体，负责处理来自客户端的请求。
- Client Manager：管理客户端（包括Producer和Consumer）和维护Consumer的topic订阅信息
- Store Service：提供API接口，来方便消息存储到物理硬盘，以及查询消息
- HA Service：提供Master Broker和Slave Broker之间的数据同步功能
- Index Service：根据特定的Message Key对投递到Broker的消息进行索引服务，便于快速查询

<!-- ![部署架构](https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_architecture_3.png) -->

### 2.3.2. 部署架构

#### 2.3.2.1. 网络部署
- NameServer

无状态的节点，集群部署
- Broker

Master和Slave节点是一对多的关系。对应的一组，BrokerName相同，BrokerId为0的是Master节点，其余为Slave节点。

每个Broker与NameServer集群中的**所有节点**都建立长连接，定时注册topic信息到所有的NameServer。
- Producer

与**随机一个**NameServer中的节点建立长连接，定期从中获取topic的路由信息；

向提供topic服务的Master节点建立长连接，定期发送心跳；

Producer节点是无状态的，可以集群部署。

- Consumer


## 2.4. 设计-消息存储

提纲：
- 消息存储整体架构
- PageCache与Mmap内存映射
- 两种刷盘方式

### 2.4.1. 消息存储整体架构

![存储架构](imgs/rocketmq_design_1.png)

#### 2.4.1.1. CommitLog
存放消息主体和元数据。Producer写入的消息存放在这里，顺序写入这个日志文件中。文件名代表了当前文件存放的消息的起始偏移量。

#### 2.4.1.2. ConsumeQueue
提高消息消费的性能。RocketMQ的消费是针对topic进行的（基于topic的订阅模式），但如果遍历CommitLog来检索其中的topic效率很低。

ConsumeQueue是消费消息的**索引**，它保存了指定topic下的队列消息在CommitLog中的起始偏移量offset，消息大小size和消息tag的HashCode值。本质上就是基于topic的索引文件，索引的对象是物理存储空间CommitLog。

文件夹组织结构：/comsumequeue/{topic}/{queueId}/{fileName}

文件中的每个条目定长20字节（8B commitLog物理偏移量 + 4B 消息长度 + 8B tag的HashCode）；单个文件中包含300k条目，可以随机访问（数组）。

#### 2.4.1.3. IndexFile
也是一种索引文件，可以通过key或时间区间来查询消息（对比ConsumeQueue是通过topic来进行索引的）。文件名是通过创建时候的时间戳来命名的。

#### 存储方式
针对Producer和Consumer采用**数据和索引相分离**的存储结构。

- Producer发送消息至Broker端
- Broker端使用同步/异步方式对消息刷盘持久化，保存到CommitLog中。此时，Producer发送的消息已经不会丢失了。
- 因而，Consumer一定有机会去消费这条消息。无法拉取的时候，可以等下一次。

### 页缓存和内存映射
- 数据的写入

OS先写入Cache中，随后通过异步的方式进行刷盘。
- 数据的读取

如果一次读取文件的时候，在Cache中没有命中，那么就会去磁盘读取目标文件，并且顺序读取相邻块的数据到Cache中（局部性原理）。

### 消息刷盘
- 同步

当且仅当消息持久化到disk中的时候，才返回ack给Producer。可靠性最高，性能影响大，金融业务应用较多。
- 异步

利用PageCache的优势，只要消息写入Cache就返回ack。刷盘在后台异步线程中完成，慢慢提交到disk中。

## 设计-通信机制
通讯流程，老生常谈了：
1. Broker启动后，会将自己注册到NameServer中，并且定时上报自己存储的topic路由信息。
2. Producer发送消息的时候，根据topic从本地缓存的TopicPublishInfoTable中获取对应的路由信息。如果本地缓存中没有记录这个topic，就需要去NameServer拉取一次路由信息（更新本地缓存中的路由）。另，Producer会定时拉取。
3. Producer根据2中获得的路由信息选择一个MessageQueue来发送消息。Broker接收消息，并落盘。
4. Consumer根据2中获得的路由信息，在完成客户端的负载均衡之后，选择若干个消息队列来拉取消息。

> 良好的网络通信模块在MQ的设计中至关重要。

### Remoting通信类结构
对应项目中的Remoting模块。是RocketMQ中负责网络通信的模块。

### 协议，编码解码
RocketMQ自定义了通信协议，用于支持Client和Server之间完成消息发送。

remoting.protocol.RemotingCommand类封装了消息传输过程中用到的数据内容。

具体字段和编码见文档中表格。

### 消息的通信方式和流程
- 同步（sync）：最严格
- 单向（oneway）：不需要关注response，一般用在发送心跳信号的场景
- 异步（async）：文档中的流程图

### Reactor多线程设计

#### Netty
> RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循Reactor多线程模型。

Netty是一个Java网络编程框架。允许通过编程自定义通信协议，自己来编码和解码字节流。

基于NIO开发的网络通信框架，并发性能得到很大的提高。在NIO中，一个Socket建立好之后，Thread并不会阻塞地去接受它，而是会放入一个Selector中。选择器不断遍历加入进来的Socket，对于建立完成的Socket，它就通知Thread去进行数据处理。

## 设计-消息过滤
Consumer端订阅消息的时候进行消息过滤。通过在逻辑队列ConsumerQueue中获取消息的索引，然后根据索引在CommitLog中读取消息实体。
支持的过滤方式：
- tag
- SQL92

## 设计-负载均衡
RocketMQ中的负载均衡都在Client端完成。

### Producer发送消息时
1. 根据topic找到指定的TopicPublishInfo，获取路由信息，在里面的messageQueueList中选择一个MessageQueue来发送消息。
2. MQFaultStrategy中会定义容错策略。
3. sendLatencyFaultEnable开关变量，如果开启，会过滤掉不可用的Broker
4. latencyFaultTolerance机制，对之前失败的情况按照一定时间进行退避。如果关闭，就会采用随机递增取模的方式选择一个队列来发送消息。**该机制是实现消息发送高可用的核心**。

### Consumer拉取消息时
0. Push方式是对Pull方式的进一步封装，即每次消息拉取线程从server拉取到一批消息后，又马不停蹄的继续再次尝试拉取。如果没有获得到，则延迟一下。Consumer需要知道从Broker中的哪一个消息队列中来获取消息，所以需要对Broker中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer来进行负载均衡处理。
1. Consumer端发送心跳信号。
2. 核心类：RebalanceImpl。

# 3. 部署笔记

## 3.1. quick start
> 文档：https://rocketmq.apache.org/docs/quick-start/

### 3.1.1. 安装包
- JDK 1.8
- Git
- Maven

1. 官网下载Maven最新版本

2. 安装在/usr/local/文件夹中

  解压指令：
  ```shell
  tar -zxvf [filename]
  ```
3. 添加环境变量
  打开配置文件
  ```shell
  vim /etc/profile
  ```
  增加路径
  ```
  MAVEN_HOME=/usr/local/maven/apache-maven-3.6.3
  export PATH=${MAVEN_HOME}/bin:${PATH}
  ```
  执行
  ```shell
  source /etc/profile
  ```

### 3.1.2. demo运行
1. 根据文档中的步骤执行example.quickstart的Producer和Consumer，这是最基础的生产者和消费者用例。

2. example中的其他包，代表了其他各种用法的Producer和Consumer的使用例子，展示了RocketMQ为消息队列提供的各种方法和功能。在文档里面都有介绍。




### 3.1.3. 问题解决
- Broker.log文件不存在

1. 需要安装jdk，并配置JAVA_HOME环境变量。之前系统预装的openjdk不靠谱。

参见 https://blog.csdn.net/weixin_38384296/article/details/102883108

2. 服务器的内存资源不足以支持RocketMQ的默认配置，需要修改两个配置文件：

参见 https://blog.csdn.net/weixin_38384296/article/details/102884039 中的[其他]部分。

### 3.1.4. 一些指令

#### 3.1.4.1. nohup
no hang up 不挂断，执行的指令在终端关闭后仍会运行。

& 是在后台运行的意思。但当用户挂起的时候，命令自动也跟着退出。

执行命令后，显示：
```shell
nohup: input and appending output to ‘nohup.out’
```

#### 3.1.4.2. tail
显示文件最尾部的内容
```shell
tail -f [filename]
```



